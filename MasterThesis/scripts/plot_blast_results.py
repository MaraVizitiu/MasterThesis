#!/usr/bin/env python3
"""
Title: plot_blast_results.py

Author: Mara Vizitiu

Description: This script uses a parsed blast results file generated by the script parse_blast.py and returns a pie chart containing the taxonomic provenance of a specified number of top hits to each query in the input file. Taxonomic provenances are summarized by a user-selected taxonomic rank (e.g., phylum).

Usage: python3 plot_blast_results.py [-h] -i parsed blast result file -o output file [-n] -r taxonomic rank -t number of hits
"""

#%% Importing modules

import matplotlib.pyplot as plt
import seaborn as sns

from ete3 import NCBITaxa
ncbi = NCBITaxa()

import argparse

#%%Setting up argparse

parser = argparse.ArgumentParser(description = "This script can create a pie chart of the distribution of the hits from a BLAST analysis by a user-specified taxonomic rank.")

parser.add_argument("-i", "--input", metavar = "parsed blast file", required = True, help = "Input file that is a parsed blast file")
parser.add_argument("-o", "--output", metavar = "output file", required = True, help = "Name of the output file that is a pdf file containing the pie chart")
parser.add_argument("-n", "--ncbi", action="store_true", required = False, help = "Download or update NCBI Taxonomy database")
parser.add_argument("-r", "--rank", metavar = "taxonomic rank", required = True, help = "Taxonomic rank used to generate pie chart")
parser.add_argument("-t", "--top", metavar = "number of hits", required = False, help = "The number of top hits to show in the plot. If argument is not specified, all hits are plotted")

args = parser.parse_args()

#%%Download and/or update NCBI Taxonomy database

#If the argument is specified, then download/update the local copy of NCBI Taxonomy
if args.ncbi:
    ncbi.update_taxonomy_database()

#%%Assign variables from arguments

input_file = open(args.input, "r", encoding="utf-8") #input file
plot_by = args.rank                         #taxonomic rank to plot by
count_dict = {}                             #dictionary that keeps track of the different OTUs that the hits belong to and their occurrences

#%%

#If a number of top hits is given, then assign that number to a variable. When no such argument is given, allow all hits to be plotted by giving the variable an inifnite value
if args.top:
    number_of_hits = int(args.top)
else:
    number_of_hits = float("inf")

#Parse the input file and check the OTU (based on the user-specified taxonomic rank) that each hit belongs to
for line in input_file: 
    if int(line.split("\t")[6]) <= number_of_hits: #only plot those hits that are in the top specified by the user
        clean_lineage_list = []                 #list that will contain only the clades that have an assigned taxID
        lineage = line.split("\t")[7].rstrip()  #get the lineage of the hit from the parsed blast file
        lineage_list = lineage.split(";")       #make a list of all the OTUs in the lineage
        #Remove any items containing the " symbol from lineage_list since these items cannot be assigned taxIDs
        for i in lineage_list:
            if "\"" not in i:
                clean_lineage_list.append(i)
        #clean_lineage_list = list(filter(None, lineage_list)) #remove empty strings from the list (empty strings are generated when pre-processing the input files before using them in this script by removing parts of the lineages that are not recognized by NCBI Taxonomy)
        taxid_dict = ncbi.get_name_translator(clean_lineage_list) #save the corresponding taxIDs for each OTU in the lineage
        for x,y in taxid_dict.items():          #iterate through the dictionary of clades and taxIDs
            current_rank = ncbi.get_rank(y)     #for each taxID get the corresponding taxonomic rank
            for taxonomy in current_rank.values(): #the taxonomic rank information is saved as a dictionary, so we iterate through the list of values (containing one rank corresponding to one taxID)
                if taxonomy == plot_by.lower(): #if the rank corresponds to that specified by the user, then save that information into count_dict
                    if x in count_dict.keys():  #if the OTU is already in the dictionary
                        count_dict[str(x)] += 1 #increase its count by 1
                    else:                       #if an OTU is encountered for the first time
                        count_dict[str(x)] = 1  #begin its count at 1

#%%Plot

frequency_dict = {} #dictionary that will store frequency information for each taxon
freq_other = 0

for taxon in count_dict.keys():
    frequency = "{:.2f}".format(count_dict[taxon]/sum(count_dict.values())*100)
    if float(frequency) < 1:
        freq_other += float(frequency)
    else:
        frequency_dict[taxon] = frequency
frequency_dict["Other"] = "{:.2f}".format(freq_other)

final_dict = {}
for item in frequency_dict:
    label = "{} {}%".format(item, frequency_dict[item])
    final_dict[label] = frequency_dict[item]

#Use the information stored in count_dict to assign the parameters of the pie chart
labels = final_dict.keys()                  #list of labels for the pie chart
sizes = final_dict.values()                 #list of sizes for the slices of the pie chart

colors = sns.color_palette("Set2", 15) #set color palette

#Generate the pie chart
pie = plt.pie(sizes, colors=colors)
plt.axis("equal")                           #equal aspect ratio ensures that pie is drawn as a circle
plt.legend(pie[0], labels, loc="center right")

#Save the pie chart to an output file in the pdf format
plt. savefig(args.output, format="pdf", bbox_inches="tight")
plt.show()

#%%

#Close the input file
input_file.close()